## 事件不用用变量进行触发

​    例：@click="btn.targetName"
​        触发点击是会去直接寻找对应的值
​        但是 btn.targetName 的值为 'close'，一个字符串，不是函数
​        不能进行触发
​    解决方法
​        可以在method中使用事件代理
​        @click="handler(btn.targetName)"
​        然后在代理中触发对应事件

## Babel版本问题导致不能进行解构引入

​	例：import {data} from '@/data'

​			此时data为空，说明引入失败

​	解决方法：先进行全部引入，之后再进行解构

​			import data from '@/data'

​			const {data}=data

​			

## 路由跳转的时候，不能去跳到同一个路由

​	可以用window.open（url,'_blank'）新开一个页面解决



## 组件传值

传递数组的时候，有操作对直接对数组赋值为空数组，因为传的是引用地址，赋值之后，引用地址改变了，但是子组件中用的还是原来的内存地址，所以数据还并没有变为空

this.catalogList=[]  不能直接赋空值，因为inject是用的引用地址，直接赋值后引用地址变了，没有关系了



# 单点登录和我的文章新开页面冲突了

在新开的页面上也算登录，就变成多点登录了，会导致原页面被迫下线

改后端的逻辑，新加个字段，如果是主动跳转的话就加入users的socket数组里面（之前的就是一个普通类型的数据，如果有同样的账号登录了的话就把原来的注销），然后现在的话就是判断这个新的字段，如果是直接进入的页面的话就用foreach去将迭代进行下线。

但是因为我现在新开的页面也是正常登录的，就导致我的那个聊天室有问题，一个用户发送出去的信息，另一个页面也会显示是别人发送的，而不是自己，然后我就在后端发送数据的时候带了个uid，在前端判断这个uid是不是和自己的uid一样，一样的话就是自己发的。